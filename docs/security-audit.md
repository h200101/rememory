# Security Audit: ReMemory

> **This audit is AI-assisted.** It was generated by Claude (Opus 4.6) to provide a structured, reproducible evaluation of the ReMemory codebase. Every finding is backed by a command you can run or a code path you can read yourself. The AI's role is directing attention to the right places; your terminal is the source of truth.

**Audit date:** 2026-02-11
**Commit:** [`8794350`](https://github.com/eljojo/rememory/blob/8794350/go.mod) (main branch)
**Go version:** 1.25.3
**Intended audience:** Security professionals and security-conscious users evaluating whether to trust this software

---

## Table of Contents

1. [Is This Software Safe to Install and Run?](#1-is-this-software-safe-to-install-and-run)
2. [Is This Software Secure for Its Purpose?](#2-is-this-software-secure-for-its-purpose)
3. [Threat Model](#3-threat-model)
4. [Deep Dives](#4-deep-dives)
5. [Where a Professional Reviewer Should Focus](#5-where-a-professional-reviewer-should-focus)
6. [What This Audit Did Not Cover](#6-what-this-audit-did-not-cover)

---

### Confidence Labels

Each finding ends with a confidence label indicating the type of evidence behind it:

- **Tool output** — produced by running a specific command. You can reproduce it yourself.
- **Code pointer** — based on reading the source code. The relevant file and line are cited so you can verify.
- **Structural observation** — follows from the architecture or design, not a single line of code. Requires understanding the system as a whole.

These are honest about what the AI can and can't verify. Tool output is the strongest claim. Code pointers and structural observations require human judgment to confirm.

---

## 1. Is This Software Safe to Install and Run?

### 1.1 Dependency Vulnerability Scanning

#### govulncheck (Go's official vulnerability database)

```bash
nix shell nixpkgs#govulncheck -c govulncheck -show verbose ./...
```

**What it checks:** Scans your Go code and dependencies against the official Go vulnerability database. Only reports vulnerabilities in functions your code actually calls.

**Output at time of audit:**

```
=== Symbol Results ===
No vulnerabilities found.

Your code is affected by 0 vulnerabilities.
This scan also found 2 vulnerabilities in packages you import and 2
vulnerabilities in modules you require, but your code doesn't appear to call
these vulnerabilities.
```

**Confidence:** Tool output — run it yourself to verify.

The 4 non-affecting vulnerabilities are all in the Go standard library (go1.25.5), not in third-party dependencies:

| ID | Package | Description | Status |
|----|---------|-------------|--------|
| GO-2026-4342 | archive/zip | Excessive CPU in index building | Code imports package but doesn't call affected symbols |
| GO-2026-4341 | net/url | Memory exhaustion in query parsing | Code imports package but doesn't call affected symbols |
| GO-2026-4340 | crypto/tls | Handshake at wrong encryption level | Module required but not used |
| GO-2026-4337 | crypto/tls | Unexpected session resumption | Module required but not used |

These are resolved by updating Go to 1.25.7+. None are exploitable through ReMemory's code paths — the CLI makes no network connections and doesn't parse untrusted URLs.

#### gosec (Go security static analysis)

```bash
nix shell nixpkgs#gosec -c gosec -quiet -fmt text ./...
```

**What it checks:** Static analysis for common Go security issues (hardcoded credentials, path traversal, file permissions, integer overflow, etc.)

**Output at time of audit:** 28 findings across 3 severity levels.

**HIGH severity (2 findings) — integer overflow in tar file mode conversion:**

Both are `os.FileMode(header.Mode)` conversions (int64 to uint32) at [`internal/manifest/archive.go:189`](https://github.com/eljojo/rememory/blob/8794350/internal/manifest/archive.go#L189) and [`archive.go:207`](https://github.com/eljojo/rememory/blob/8794350/internal/manifest/archive.go#L207). In practice, tar file modes are small positive integers and this conversion is safe. A reviewer should verify that the archive contents are always self-generated.

**MEDIUM severity (18 findings):**

| Category | Count | Assessment |
|----------|-------|------------|
| G304 — File inclusion via variable | 8 | Expected: CLI reads user-specified paths. Not a vulnerability. |
| G301 — Directory permissions 0755 | 6 | Standard for directories. Shares (sensitive) use 0600. |
| G306 — File permissions 0644 | 3 | Applies to MANIFEST.age, project.yml, HTML output. See [Section 4.1](#41-passphrase-lifecycle) for discussion. |
| G305 — Tar path traversal | 1 | Flagged at `archive.go:180`, but the code has a traversal check at line 183. False positive. |
| G101 — Hardcoded credentials | 2 | Both in `demo.go` — intentional demo placeholder text. |

**LOW severity (4 findings):** Unchecked `f.Close()` and `gz.Write()`/`gz.Close()` error returns. Minor robustness issues, not security vulnerabilities.

**Confidence:** Tool output — run it yourself.

#### syft + grype (SBOM generation + vulnerability scanning)

```bash
nix shell nixpkgs#syft -c syft dir:. -o json > /tmp/rememory-sbom.json
nix shell nixpkgs#grype -c grype sbom:/tmp/rememory-sbom.json --output table
```

**What it checks:** Generates a Software Bill of Materials (SBOM), then scans all identified packages against multiple vulnerability databases (NVD, GitHub Advisories, etc.)

**Output at time of audit:**

| Package | Installed | Fixed In | CVE | Severity |
|---------|-----------|----------|-----|----------|
| stdlib | go1.25.5 | 1.25.6 | CVE-2025-61726 | High |
| stdlib | go1.25.5 | 1.25.6 | CVE-2025-61730 | Medium |
| stdlib | go1.25.5 | 1.25.7 | CVE-2025-68121 | Critical |
| stdlib | go1.25.5 | 1.25.6 | CVE-2025-61728 | Medium |
| stdlib | go1.25.5 | 1.25.6 | CVE-2025-68119 | High |
| stdlib | go1.25.5 | 1.25.7 | CVE-2025-61732 | High |
| stdlib | go1.25.5 | 1.25.6 | CVE-2025-61731 | High |

All vulnerabilities are in the Go standard library — no third-party dependency vulnerabilities found. Updating to Go 1.25.7 resolves all of them. As noted above, govulncheck confirms none of these affect ReMemory's actual code paths.

#### go vet + go mod verify

```bash
nix develop -c go vet ./...      # Static analysis from Go toolchain
nix develop -c go mod verify     # Verify dependency checksums
```

**Output at time of audit:**

- `go vet`: Clean — no issues found.
- `go mod verify`: `all modules verified` — every dependency matches its recorded checksum in `go.sum`.

**Confidence:** Tool output.

### 1.2 Dependency Surface

```bash
# Direct dependencies (go.mod)
nix develop -c go list -m all | head -1   # ReMemory itself
nix develop -c go list -m -json all | grep -c '"Indirect": true'  # Count indirect
```

**Direct dependencies (7):**

| Dependency | Version | Purpose | Touches sensitive data? |
|------------|---------|---------|----------------------|
| [`filippo.io/age`](https://github.com/FiloSottile/age) | v1.3.1 | Encryption (scrypt + ChaCha20-Poly1305) | Yes — encrypts/decrypts manifest |
| [`github.com/hashicorp/vault`](https://github.com/hashicorp/vault) | v1.21.2 | Shamir's Secret Sharing (shamir subpackage only) | Yes — splits/combines passphrase |
| [`golang.org/x/text`](https://pkg.go.dev/golang.org/x/text) | v0.33.0 | Unicode normalization for BIP39 words | Yes — word decoding touches share data |
| [`github.com/go-pdf/fpdf`](https://github.com/go-pdf/fpdf) | v0.9.0 | PDF generation for bundle README | Renders share words into PDF |
| [`github.com/skip2/go-qrcode`](https://github.com/skip2/go-qrcode) | v0.0.0-20200617 | QR code generation for PDF | Encodes compact share into QR |
| [`github.com/spf13/cobra`](https://github.com/spf13/cobra) | v1.10.2 | CLI framework | No |
| [`gopkg.in/yaml.v3`](https://pkg.go.dev/gopkg.in/yaml.v3) | v3.0.1 | YAML parsing for project.yml | Reads project config |

**Indirect dependencies (7):** `filippo.io/hpke`, `go-md2man`, `mousetrap`, `blackfriday`, `pflag`, `go.yaml.in/yaml/v3`, `golang.org/x/crypto`, `golang.org/x/sys`

**Total modules in dependency graph:** ~560 (the large count is due to `hashicorp/vault` pulling in its full module graph, though only the `shamir` subpackage is imported).

**Key observation:** The dependency tree is dominated by HashiCorp Vault's module graph. Only the `shamir` subpackage is imported:

```bash
grep -r "hashicorp/vault" --include="*.go" . | grep -v _test.go | grep -v vendor
# Expected: only internal/core/shamir.go importing "github.com/hashicorp/vault/shamir"
```

**Confidence:** Tool output + code pointer.

### 1.3 No Network Calls

```bash
# Check all Go imports for networking packages
nix develop -c go list -f '{{.ImportPath}}: {{.Imports}}' ./cmd/... ./internal/... 2>/dev/null | grep -E "net/http|net\""

# Expected: empty output
```

The CLI makes zero network requests. Verify:

```bash
# No os/exec usage (no shelling out)
grep -rn "os/exec" --include="*.go" . | grep -v _test.go
# Expected: no matches

# No telemetry or analytics
grep -ri "telemetry\|analytics\|tracking\|sentry\|datadog" --include="*.go" --include="*.js" . --exclude-dir=node_modules
# Expected: no matches
```

**Confidence:** Tool output — run these yourself.

### 1.4 No Network in Recovery Tool

The browser-based `recover.html` is self-contained:

```bash
# Check for external script loading
grep -E "<script.*src=" internal/html/assets/recover.html
# Expected: no matches

# Check for fetch/XHR calls in compiled JS
grep -n "fetch\|XMLHttpRequest\|sendBeacon" internal/html/assets/app.js
# Expected: one match — fetch('recover.wasm') — a relative path fallback
```

WASM is gzip-compressed and base64-encoded inline. The only `fetch` call is a local fallback for `recover.wasm` that fails silently when running from `file://` and uses the embedded binary instead. See [`internal/html/assets/src/shared.ts`](https://github.com/eljojo/rememory/blob/8794350/internal/html/assets/src/shared.ts) for the WASM loading logic.

**Confidence:** Tool output + code pointer.

### 1.5 WASM Import Inspection

You can verify that the WASM binary doesn't import unexpected host functions:

```bash
# Build recover.wasm and inspect its imports
make wasm
wasm-objdump -x internal/html/assets/recover.wasm -j Import 2>/dev/null || \
  nix shell nixpkgs#wabt -c wasm-objdump -x internal/html/assets/recover.wasm -j Import
```

Expected: only Go runtime imports (`gojs` namespace — `syscall/js` bridge functions like `valueGet`, `valueSet`, `valueCall`). No `fetch`, `XMLHttpRequest`, or Web API imports.

**Confidence:** Tool output.

### 1.6 Ongoing Dependency Monitoring

The repository does not currently have a Dependabot configuration file. Dependency monitoring relies on manual `govulncheck` runs and Go module tools.

---

## 2. Is This Software Secure for Its Purpose?

This section covers the cryptographic composition and whether the Shamir/age construction holds. Tools reach their limit here — the real assurance comes from reading code.

### 2.1 Cryptographic Composition

The design composes two well-established primitives:

1. **age** (scrypt mode) encrypts the manifest with a random passphrase
2. **Shamir's Secret Sharing** (HashiCorp Vault) splits the passphrase into shares

The composition is sound if:
- The passphrase has sufficient entropy (it does: 256 bits from `crypto/rand`)
- The Shamir split operates on the raw passphrase bytes (it does in v2)
- Below-threshold shares reveal zero information about the passphrase (guaranteed by Shamir's information-theoretic security)
- Share metadata doesn't leak information that weakens the guarantee (it doesn't — see [Section 4.2](#42-share-format-and-metadata-leakage))

### 2.2 What the Code Does (High-Level)

**Sealing (creation):**
1. Archive `manifest/` directory into tar.gz (in memory)
2. Generate 32 random bytes via `crypto/rand` → base64url encode → passphrase
3. Encrypt tar.gz with age (scrypt mode, passphrase)
4. Split raw 32 bytes via Shamir into N shares with threshold K
5. Verify reconstruction: combine K shares, re-derive passphrase, compare
6. Write MANIFEST.age (encrypted), share files (0600), ZIP bundles

**Recovery (reconstruction):**
1. Parse share files, verify checksums
2. Validate compatibility (version, total, threshold must match)
3. Check threshold met, no duplicate indices
4. Combine shares via Shamir → recover raw bytes → base64url encode → passphrase
5. Decrypt MANIFEST.age with recovered passphrase
6. Extract tar.gz to output directory

**Code pointers:**
- Seal: [`internal/cmd/seal.go:82-250`](https://github.com/eljojo/rememory/blob/8794350/internal/cmd/seal.go#L82-L250)
- Recover: [`internal/cmd/recover.go:44-203`](https://github.com/eljojo/rememory/blob/8794350/internal/cmd/recover.go#L44-L203)

**Confidence:** Structural observation — verified by reading the code paths end-to-end.

---

## 3. Threat Model

### 3.1 An attacker who obtains fewer than threshold shares

**Design promise:** Zero information about the passphrase is revealed. This is Shamir's information-theoretic guarantee — it holds regardless of computational power.

**What enforces it:**
- [`internal/core/shamir.go:14-25`](https://github.com/eljojo/rememory/blob/8794350/internal/core/shamir.go#L14-L25) — delegates to `github.com/hashicorp/vault/shamir.Split()`, which operates over GF(2^8).
- The share data itself is a Shamir share — a point on a random polynomial. No additional information is embedded in the share data bytes.

**What to verify:** That share metadata doesn't leak information. See [Section 4.2](#42-share-format-and-metadata-leakage).

**Confidence:** Code pointer + structural observation. The information-theoretic guarantee follows from the mathematical properties of Shamir's Secret Sharing, not from the implementation. The implementation's job is to not add leakage, and it doesn't.

### 3.2 An attacker who compromises a single friend's bundle

**Design promise:** A single bundle reveals that friend's share (one point on the polynomial) and the encrypted manifest. Without threshold-1 additional shares, the passphrase cannot be reconstructed and the manifest cannot be decrypted.

**What enforces it:**
- The encrypted manifest uses age with a 256-bit random passphrase. Brute-forcing scrypt with this entropy is computationally infeasible.
- The share gives one Shamir point — information-theoretically insufficient to reconstruct the secret when K >= 2.

**What's in the bundle:**

| File | Contents | Reveals |
|------|----------|---------|
| README.txt / README.pdf | Instructions + share (PEM + words) | The friend's single share + scheme parameters (N, K) |
| MANIFEST.age | age-encrypted archive | Nothing (encrypted with 256-bit passphrase) |
| recover.html | Self-contained recovery tool + personalization | Friend names, contact info, the friend's pre-loaded share |

**Personalization data** embedded in `recover.html` includes friend names and contact info for all friends. This is intentional — it helps coordinate recovery. It does not leak cryptographic material.

**Code pointer:** [`internal/bundle/bundle.go`](https://github.com/eljojo/rememory/blob/8794350/internal/bundle/bundle.go) for bundle generation, [`internal/html/recover.go`](https://github.com/eljojo/rememory/blob/8794350/internal/html/recover.go) for personalization embedding.

**Confidence:** Code pointer + structural observation.

### 3.3 An attacker with access to the creator's machine after sealing

**Design promise:** After sealing, the creator's machine holds the encrypted manifest and all share files. An attacker with full disk access can read everything.

**What this means:**
- The attacker has all N shares → they can reconstruct the passphrase → they can decrypt the manifest. **This is by design.** The seal operation creates shares that are meant to be distributed; until distribution, they're all in one place.
- After distribution, the creator should delete the share files. The project doesn't automate this.

**What remains on disk after sealing:**

| File | Permissions | Contains |
|------|------------|----------|
| `output/MANIFEST.age` | 0644 | Encrypted archive |
| `output/shares/SHARE-*.txt` | 0600 | Individual shares (PEM format) |
| `output/bundles/bundle-*.zip` | 0644 | Complete bundles for each friend |
| `project.yml` | 0644 | Friend names, SHA-256 of passphrase, share checksums |

**Note:** `project.yml` stores `sha256:<hash of passphrase>` as a verification hash. This is a one-way hash of a 256-bit random value — offline brute force is infeasible.

```bash
# Verify share file permissions
grep -n "0600" internal/cmd/seal.go
# Line 155: os.WriteFile(sharePath, []byte(share.Encode()), 0600)
```

**Confidence:** Code pointer.

### 3.4 A malicious or compromised dependency

**Design promise:** The code relies on established cryptographic libraries rather than custom primitives. Dependencies are pinned by `go.sum` checksums.

**What enforces it:**
- `go mod verify` confirms all module checksums match their recorded values.
- Only 2 dependencies touch sensitive data: `filippo.io/age` (encryption) and `github.com/hashicorp/vault/shamir` (secret sharing).
- Both are widely used, maintained, and have existing security audits.

**What to verify:**
```bash
# Confirm no tampering
nix develop -c go mod verify
# Expected: "all modules verified"

# Review the full dependency graph
nix develop -c go mod graph | grep "github.com/eljojo/rememory " | sort
```

**Residual risk:** A compromised version of age or vault could exfiltrate secrets. This is mitigated by pinned versions and checksums, but not eliminated. govulncheck provides ongoing monitoring for known vulnerabilities.

**Confidence:** Tool output + structural observation.

### 3.5 A friend who acts alone trying to recover the secret

**Design promise:** A single friend cannot recover the secret when threshold >= 2.

**What enforces it:**
- **Creation time:** [`internal/core/shamir.go:46`](https://github.com/eljojo/rememory/blob/8794350/internal/core/shamir.go#L46) — threshold must be >= 2.
- **Recovery time (CLI):** [`internal/cmd/recover.go:87-89`](https://github.com/eljojo/rememory/blob/8794350/internal/cmd/recover.go#L87-L89) — checks `len(shares) < first.Threshold` before attempting combination.
- **Recovery time (WASM):** [`internal/wasm/recover.go:82`](https://github.com/eljojo/rememory/blob/8794350/internal/wasm/recover.go#L82) — checks `len(shares) < 2`.
- **Underlying library:** `vault.Combine()` will error if given fewer than K shares.

The WASM path checks for minimum 2 shares but doesn't validate against the specific threshold K — however, Shamir reconstruction with fewer than K shares produces garbage, and the subsequent age decryption will fail with "incorrect passphrase."

```bash
# Verify threshold validation at creation
grep -n "threshold must be at least 2" internal/core/shamir.go
# Line 47

# Verify threshold check at recovery
grep -n "Threshold" internal/cmd/recover.go | head -5
# Lines 82-89: validates shares >= threshold
```

**Confidence:** Code pointer.

---

## 4. Deep Dives

### 4.1 Passphrase Lifecycle

**Generation:** [`internal/crypto/passphrase.go:26-39`](https://github.com/eljojo/rememory/blob/8794350/internal/crypto/passphrase.go#L26-L39)

```go
raw = make([]byte, numBytes)             // 32 bytes
if _, err := rand.Read(raw); err != nil  // crypto/rand (OS CSPRNG)
passphrase = base64.RawURLEncoding.EncodeToString(raw)  // ~43 chars
```

- Uses `crypto/rand` exclusively — verify: `grep -rn "math/rand" --include="*.go" . | grep -v _test.go` should return no matches.
- 32 bytes = 256 bits of entropy. Minimum enforced at line 27-28 (>= 16 bytes).

**Usage during seal:** [`internal/cmd/seal.go:112-198`](https://github.com/eljojo/rememory/blob/8794350/internal/cmd/seal.go#L112-L198)

1. `raw, passphrase` generated (line 112)
2. `passphrase` used for age encryption (line 122)
3. `raw` bytes split via Shamir (line 141) — v2 splits raw bytes, not the base64 string
4. Reconstruction verified: K shares combined, re-encoded, compared (lines 174-186)
5. `HashString(passphrase)` stored in project.yml (line 198) — SHA-256 hash, not plaintext

**What the reader should verify:**
- The passphrase is never logged or printed (except with explicit `--passphrase-only` flag at [`recover.go:116-121`](https://github.com/eljojo/rememory/blob/8794350/internal/cmd/recover.go#L116-L121)).
- Error messages don't include the passphrase — check all `fmt.Errorf` calls in seal.go and recover.go.
- The passphrase is **not zeroed** from memory after use. This is a known limitation of Go — `runtime.GC()` is non-deterministic and Go doesn't provide `mlock`/`mprotect` wrappers. The passphrase bytes persist in heap until garbage collected. This is standard for Go crypto code (age itself has the same property).

**Confidence:** Code pointer — the reader must read these functions and judge.

### 4.2 Share Format and Metadata Leakage

**PEM format:** [`internal/core/share.go:62-87`](https://github.com/eljojo/rememory/blob/8794350/internal/core/share.go#L62-L87)

```
-----BEGIN REMEMORY SHARE-----
Version: 2
Index: 1
Total: 5
Threshold: 3
Holder: Alice
Created: 2026-02-11 15:04
Checksum: sha256:abc123...

<base64 encoded share data>
-----END REMEMORY SHARE-----
```

**Headers and what they reveal:**

| Header | Value | Weakens below-threshold guarantee? |
|--------|-------|-----------------------------------|
| Version | Protocol version (1 or 2) | No — public parameter |
| Index | Share number (1-N) | No — required by Shamir (x-coordinate) |
| Total | N (total shares) | No — public scheme parameter |
| Threshold | K (required shares) | No — public scheme parameter |
| Holder | Friend's name | No — identifies holder, not secret |
| Created | Timestamp | No — operational metadata |
| Checksum | SHA-256 of share data | No — derived from share, not from secret |

**Key observation:** None of these headers are derived from the secret passphrase. The checksum is a hash of the share data (a Shamir point), not of the secret. The Index is the x-coordinate for Shamir interpolation — it's a required public parameter.

**Compact format** (QR codes): [`share.go:217-221`](https://github.com/eljojo/rememory/blob/8794350/internal/core/share.go#L217-L221) — `RM2:1:5:3:<base64url>:<4-char checksum>`. Same metadata exposure.

**Word encoding** (BIP39): Word 25 encodes 4 bits of share index + 7 bits of checksum. The checksum is over the share data bytes, not the secret.

**Confidence:** Code pointer — the reader should verify that `HashBytes(data)` at [`share.go:47`](https://github.com/eljojo/rememory/blob/8794350/internal/core/share.go#L47) hashes `data` (the Shamir share), not the original secret.

### 4.3 WASM/JS Boundary

**Exposed functions:** [`internal/wasm/main_recover.go`](https://github.com/eljojo/rememory/blob/8794350/internal/wasm/main_recover.go) registers 7 functions. [`main_create.go`](https://github.com/eljojo/rememory/blob/8794350/internal/wasm/main_create.go) registers those 7 + 2 more (creation).

| Function | Input from JS | Output to JS | Validates? |
|----------|--------------|-------------|-----------|
| `parseShareJS` | string | share object | Argument count only |
| `combineSharesJS` | array of share objects | passphrase string | Argument count; version consistency checked downstream |
| `decryptManifestJS` | Uint8Array + string | Uint8Array | Argument count only |
| `extractTarGzJS` | Uint8Array | file array | Argument count; path traversal checked in core |
| `extractBundleJS` | Uint8Array | share + manifest | Argument count only |
| `parseCompactShareJS` | string | share object | Argument count; format validated downstream |
| `decodeWordsJS` | string array | data + index + checksum | Argument count; checksum validated downstream |

**What the reader should verify:**
- [`js_wrappers.go`](https://github.com/eljojo/rememory/blob/8794350/internal/wasm/js_wrappers.go) — All 7 wrapper functions. Input validation happens at argument count, but not input size. `dataLen := jsData.Get("length").Int()` (e.g., line 71) is used directly to allocate Go memory. This is acceptable because the WASM runs in the user's own browser — they're attacking themselves.
- `combineSharesJS` returns the passphrase as a JS string (line 55-56). The passphrase exists in JavaScript memory until the page unloads. This is inherent to browser-based crypto.

**Confidence:** Code pointer — the reader should read `js_wrappers.go` (~238 lines) and assess whether the data crossing the boundary is handled correctly.

### 4.4 Tar Extraction Security

Two extraction paths exist, both with security checks:

**In-memory (CLI + WASM):** [`internal/core/archive.go:33-93`](https://github.com/eljojo/rememory/blob/8794350/internal/core/archive.go#L33-L93)

| Defense | Line | Mechanism |
|---------|------|-----------|
| Path traversal | 44-59 | Regex rejects `..` path components (see `archive.go:45`) |
| Non-regular files | 62-64 | Only `tar.TypeReg` extracted; directories, symlinks, devices skipped |
| Per-file size limit | 67-68 | 100 MB maximum (`MaxFileSize`) |
| Total size limit | 70-73 | 1 GB maximum (`MaxTotalSize`) |
| LimitReader safety | 76 | Double-checked with `io.LimitReader` |

**File-based (CLI recover):** [`internal/manifest/archive.go:143-244`](https://github.com/eljojo/rememory/blob/8794350/internal/manifest/archive.go#L143-L244)

| Defense | Line | Mechanism |
|---------|------|-----------|
| Path traversal | 180-185 | `filepath.Clean(target)` must have `filepath.Clean(destDir)` as prefix |
| Symlinks | 223-225 | Skipped with warning |
| Hard links | 227-229 | Skipped with warning |
| Per-file size limit | 195-196 | Same 100 MB maximum |
| Total size limit | 198-200 | Same 1 GB maximum |
| LimitReader safety | 213-221 | `io.LimitReader` + post-copy size check |

**WASM archive creation:** [`internal/wasm/create.go:349-404`](https://github.com/eljojo/rememory/blob/8794350/internal/wasm/create.go#L349-L404) receives filenames from JavaScript. It strips leading slashes (line 372) but does not explicitly reject `..` sequences. Extraction is protected on both paths, and filenames come from the browser's File API which normalizes paths, so this is defense-in-depth rather than a direct vulnerability.

**What the reader should verify:**
- The regex at `archive.go:45` — confirm it catches all traversal patterns (`../`, `foo/../bar`, etc.)
- The `filepath.Clean` + prefix check at `archive.go:183` — confirm it's robust against path canonicalization tricks
- That symlinks in the archive don't create escape paths

**Confidence:** Code pointer.

### 4.5 Threshold Validation

**At creation:** [`internal/core/shamir.go:44-56`](https://github.com/eljojo/rememory/blob/8794350/internal/core/shamir.go#L44-L56)
- K >= 2 (line 46)
- K <= N (line 49)
- N <= 255 (line 52)

**At CLI recovery:** [`internal/cmd/recover.go:68-98`](https://github.com/eljojo/rememory/blob/8794350/internal/cmd/recover.go#L68-L98)
- Version consistency checked (lines 74-84)
- Total and threshold consistency checked (lines 79-83)
- `len(shares) >= threshold` checked (lines 87-89)
- Duplicate indices rejected (lines 92-98)

**At WASM recovery:** [`internal/wasm/recover.go:81-110`](https://github.com/eljojo/rememory/blob/8794350/internal/wasm/recover.go#L81-L110)
- Minimum 2 shares (line 82)
- Version consistency checked (lines 86-91)
- Does **not** check `len(shares) >= threshold` at the WASM layer

The WASM path relies on the underlying Shamir library to reject insufficient shares, plus age decryption will fail if the reconstructed passphrase is wrong (producing garbage from too few shares).

**Confidence:** Code pointer.

### 4.6 Dependency Deep-Dive: What Touches Sensitive Data

Only three code paths handle the actual secret (passphrase):

1. **`crypto/rand`** (Go stdlib) — generates the 32 random bytes
2. **`filippo.io/age`** — encrypts/decrypts the manifest with the passphrase via scrypt
3. **`github.com/hashicorp/vault/shamir`** — splits/combines the raw passphrase bytes

```bash
# Trace what imports touch the passphrase
grep -rn "crypto.GenerateRawPassphrase\|core.Encrypt\|core.Decrypt\|core.Split\|core.Combine" --include="*.go" . | grep -v _test.go
```

**age (v1.3.1):** Created by Filippo Valsorda (former Go security lead). Has a [formal specification](https://github.com/C2SP/C2SP/blob/main/age.md). Uses scrypt for key derivation from passphrase, ChaCha20-Poly1305 for encryption. The library has been [audited](https://github.com/FiloSottile/age/tree/main/doc) and is widely used.

**vault/shamir:** Part of HashiCorp Vault, an enterprise secrets management tool. The `shamir` subpackage implements Shamir's Secret Sharing over GF(2^8). This is battle-tested code used in production by thousands of organizations.

**Confidence:** Structural observation.

---

## 5. Where a Professional Reviewer Should Focus

Ranked by risk and time-to-review:

### Priority 1: Cryptographic Core (2-3 hours)

| File | Lines | Why |
|------|-------|-----|
| [`internal/crypto/passphrase.go`](https://github.com/eljojo/rememory/blob/8794350/internal/crypto/passphrase.go) | 40 | Passphrase generation — entropy source, byte count, encoding |
| [`internal/core/shamir.go`](https://github.com/eljojo/rememory/blob/8794350/internal/core/shamir.go) | 57 | Shamir wrapper — parameter validation, delegation to vault |
| [`internal/core/age.go`](https://github.com/eljojo/rememory/blob/8794350/internal/core/age.go) | 86 | age wrapper — empty passphrase check, scrypt mode usage |
| [`internal/core/share.go`](https://github.com/eljojo/rememory/blob/8794350/internal/core/share.go) | 329 | Share format — metadata in headers, encoding/decoding, checksum |
| [`internal/cmd/seal.go:82-250`](https://github.com/eljojo/rememory/blob/8794350/internal/cmd/seal.go#L82-L250) | 168 | Seal flow — passphrase handling, split, verify, write |
| [`internal/cmd/recover.go:44-203`](https://github.com/eljojo/rememory/blob/8794350/internal/cmd/recover.go#L44-L203) | 160 | Recover flow — combine, decrypt, extract |

**What to look for:** Passphrase leakage in error paths, correct delegation to libraries, parameter validation completeness.

### Priority 2: WASM/JS Boundary (1-2 hours)

| File | Lines | Why |
|------|-------|-----|
| [`internal/wasm/js_wrappers.go`](https://github.com/eljojo/rememory/blob/8794350/internal/wasm/js_wrappers.go) | 239 | Bridge between JS and Go — all data crossing the boundary |
| [`internal/wasm/recover.go`](https://github.com/eljojo/rememory/blob/8794350/internal/wasm/recover.go) | ~190 | WASM-side recovery logic — share parsing, combining, decryption |
| [`internal/wasm/create.go`](https://github.com/eljojo/rememory/blob/8794350/internal/wasm/create.go) | ~404 | WASM-side creation — archive building, friend name handling |

**What to look for:** Input validation gaps, data leakage through error messages, memory handling across the boundary.

### Priority 3: Archive Handling (1 hour)

| File | Lines | Why |
|------|-------|-----|
| [`internal/core/archive.go`](https://github.com/eljojo/rememory/blob/8794350/internal/core/archive.go) | 94 | In-memory tar.gz extraction with security checks |
| [`internal/manifest/archive.go`](https://github.com/eljojo/rememory/blob/8794350/internal/manifest/archive.go) | 293 | File-based tar.gz archive and extract |

**What to look for:** Path traversal bypasses, symlink handling completeness, size limit enforcement.

### Priority 4: HTML Generation (1 hour)

| File | Lines | Why |
|------|-------|-----|
| [`internal/html/recover.go`](https://github.com/eljojo/rememory/blob/8794350/internal/html/recover.go) | ~90 | Personalization embedding — `json.Marshal` into `<script>` tag |
| [`internal/html/assets/src/app.ts`](https://github.com/eljojo/rememory/blob/8794350/internal/html/assets/src/app.ts) | ~1300 | Client-side recovery logic — DOM manipulation, file handling |
| [`internal/html/assets/src/shared.ts`](https://github.com/eljojo/rememory/blob/8794350/internal/html/assets/src/shared.ts) | ~150 | Shared utilities — `escapeHtml()`, toast system |

**What to look for:** XSS vectors in HTML generation, proper escaping of user-controlled data (friend names, contact info), innerHTML usage patterns. Note: Go's `json.Marshal` HTML-escapes `<`, `>`, `&` by default (as `\u003c`, `\u003e`, `\u0026`), preventing `</script>` injection.

### Priority 5: Bundle Generation (30 min)

| File | Lines | Why |
|------|-------|-----|
| [`internal/bundle/bundle.go`](https://github.com/eljojo/rememory/blob/8794350/internal/bundle/bundle.go) | ~340 | ZIP creation, filename sanitization, manifest embedding |

**What to look for:** What goes into each bundle, whether anything extra is accidentally included.

---

## 6. What This Audit Did Not Cover

For full transparency:

- **Cryptographic correctness of age and vault/shamir.** These libraries are treated as trusted primitives. Their security properties are assumed from their specifications, audits, and track records — not verified here.
- **Side-channel attacks** beyond timing (power analysis, EM emissions, cache timing). Go's `crypto/subtle.ConstantTimeCompare` is used for hash verification ([`internal/core/hash.go:24`](https://github.com/eljojo/rememory/blob/8794350/internal/core/hash.go#L24)), but memory-resident passphrases could theoretically be extracted via side channels.
- **Memory safety of the Go runtime and WASM environment.** Go is memory-safe by design; WASM runs in a browser sandbox.
- **Supply chain attacks beyond checksum verification.** `go.sum` ensures integrity against the Go module proxy, but doesn't protect against a compromised upstream repository at the time of initial pinning.
- **Browser-specific attacks** (extensions, compromised browsers, shared machines). The recovery tool runs in whatever browser the user opens it in — it inherits that browser's security posture.
- **Physical security** (secure erasure of printed shares, bundle USB drives, etc.)
- **Formal verification** of the Shamir/age composition.

---

## Appendix A: Verification Commands

Run these from the repository root at commit `8794350`:

```bash
# 1. No vulnerabilities in called code
nix shell nixpkgs#govulncheck -c govulncheck ./...

# 2. Static security analysis
nix shell nixpkgs#gosec -c gosec -quiet -fmt text ./...

# 3. Standard Go static analysis
nix develop -c go vet ./...

# 4. Dependency integrity
nix develop -c go mod verify

# 5. SBOM + vulnerability scan
nix shell nixpkgs#syft -c syft dir:. -o json > /tmp/sbom.json
nix shell nixpkgs#grype -c grype sbom:/tmp/sbom.json --output table

# 6. No network imports
nix develop -c go list -f '{{.ImportPath}}: {{.Imports}}' ./internal/... 2>/dev/null | grep -E "net/http|net\""

# 7. No os/exec
grep -rn "os/exec" --include="*.go" . | grep -v _test.go

# 8. No telemetry
grep -ri "telemetry\|analytics\|tracking" --include="*.go" --include="*.js" . --exclude-dir=node_modules

# 9. Passphrase entropy source
grep -n "crypto/rand" internal/crypto/passphrase.go

# 10. Passphrase entropy size
grep -n "DefaultPassphraseBytes" internal/crypto/passphrase.go

# 11. Constant-time hash comparison
grep -n "ConstantTimeCompare" internal/core/hash.go

# 12. Share file permissions
grep -n "0600" internal/cmd/seal.go

# 13. Path traversal protection (in-memory)
grep -n "\\.\\." internal/core/archive.go

# 14. Path traversal protection (file-based)
grep -n "HasPrefix" internal/manifest/archive.go

# 15. Threshold minimum enforced
grep -n "threshold must be at least 2" internal/core/shamir.go

# 16. Symlinks rejected
grep -n "Symlink" internal/manifest/archive.go internal/core/archive.go

# 17. JS fetch is local only
grep -n "fetch(" internal/html/assets/app.js

# 18. Run the test suite
make test
```

---

## Appendix B: References

- [age encryption — GitHub](https://github.com/FiloSottile/age)
- [age specification (C2SP)](https://github.com/C2SP/C2SP/blob/main/age.md)
- [HashiCorp Vault shamir package](https://pkg.go.dev/github.com/hashicorp/vault/shamir)
- [Shamir's Secret Sharing — Wikipedia](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing)
- [govulncheck — Go vulnerability scanner](https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck)
- [gosec — Go security static analysis](https://github.com/securego/gosec)
- [syft — SBOM generator](https://github.com/anchore/syft)
- [grype — vulnerability scanner](https://github.com/anchore/grype)

---

*This is a point-in-time artifact auditing commit [`8794350`](https://github.com/eljojo/rememory/tree/8794350). Code links use this commit hash for permanence. For mission-critical use, this document is a starting point — not a substitute for a professional security engagement.*
